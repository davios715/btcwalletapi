package multisig

import (
	"encoding/hex"
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestIsPublicKeyValid(t *testing.T) {
	var pubKey []byte
	var err = isPublicKeyValid(pubKey)

	assert.Error(t, err, "Expected error: public key could not be empty")

	pubKey = []byte{byte(4), byte(3)}
	err = isPublicKeyValid(pubKey)

	assert.Error(t, err, "Expected error: public key length invalid")

	pubKey = []byte{}
	for i := 0; i < 65; i++ {
		pubKey = append(pubKey, byte(3))
	}
	err = isPublicKeyValid(pubKey)

	assert.Error(t, err, "Expected error: public key start with byte(3)")

	pubKey[0] = byte(4)
	err = isPublicKeyValid(pubKey)

	assert.NoError(t, err, "Expected no error: valid key")
}

func TestHash160(t *testing.T) {
	var data = []byte("mvm74FACaagz94rjWbNmW2EmhJdmEGcxpa")
	var h, err = hash160(data)

	var expected = []byte{0x74, 0x85, 0x98, 0xcd, 0x9b, 0x0, 0x4a, 0xec, 0xf8, 0xa2, 0xd9, 0x74, 0x64, 0xfb, 0x1f, 0x2a, 0x90, 0x56, 0x2f, 0xfe}
	assert.NoError(t, err , "Expected no error: correct hash")
	assert.Equal(t, expected, h, "Incorrect hash generated")
}

func TestNewMOfNRedeemScript(t *testing.T) {
	var key1 = []byte{byte(4)}
	var key2 = []byte{byte(4)}
	var key3 = []byte{byte(4)}
	for i := 0; i < 64; i++ {
		key1 = append(key1, byte(1))
		key2 = append(key2, byte(2))
		key3 = append(key3, byte(3))
	}
	var pubKeys = [][]byte{}
	pubKeys = append(pubKeys, key1, key2, key3)

	var _, err = newMOfNRedeemScript(4, 8, pubKeys)

	assert.Error(t, err, "Expected error: Invalid n value")

	_, err = newMOfNRedeemScript(4, 3, pubKeys)

	assert.Error(t, err, "Expected error: m > n")

	_, err = newMOfNRedeemScript(0, 3, pubKeys)

	assert.Error(t, err, "Expected error: m < 1")

	_, err = newMOfNRedeemScript(1, 2, pubKeys)

	assert.Error(t, err, "Expected error: n != number of public keys")

	s, err := newMOfNRedeemScript(1, 3, pubKeys)

	var expected = []byte{0x51, 0x41, 0x4, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x41, 0x4, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x41, 0x4, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x53, 0xae}

	assert.NoError(t, err, "Expected no error: correct script")
	assert.Equal(t, expected, s, "Incorrect script generated")
}

func TestGenerateAddress(t *testing.T) {
	var key1 = []byte{byte(4)}
	var key2 = []byte{byte(4)}
	var key3 = []byte{byte(4)}
	for i := 0; i < 64; i++ {
		key1 = append(key1, byte(1))
		key2 = append(key2, byte(2))
		key3 = append(key3, byte(3))
	}
	var pubKeys []string
	pubKeys = append(pubKeys, hex.EncodeToString(key1), hex.EncodeToString(key2), hex.EncodeToString(key3))

	var a, s, err = GenerateAddress(2, 3, pubKeys)
	var expectedA = "36TMYGm2uu6eDQ43KZD7MYtiq8NZGHBSui"
	var expectedS = "5241040101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010141040202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020241040303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030353ae"

	assert.NoError(t, err, "Expected no error: correct address and script")
	assert.Equal(t, expectedA, a, "Incorrect address generated")
	assert.Equal(t, expectedS, s, "Incorrect script generated")
}
